//// <auto-generated>
//using System;
//using System.Collections.Generic;
//using System.Text;
//using Microsoft.Xna.Framework;

//namespace Synergy.VirusPrototype.Shared.Drawers
//{
//	public static class Primitives2D
//	{
//		#region Private Members

//		private static readonly Dictionary<String, List<Vector2>> circleCache = new Dictionary<string, List<Vector2>>();
//		//private static readonly Dictionary<String, List<Vector2>> arcCache = new Dictionary<string, List<Vector2>>();
//		private static Texture2D pixel;

//		#endregion


//		#region Private Methods

//		private static void CreateThePixel(SpriteBatch spriteBatch)
//		{
//			pixel = new Texture2D(spriteBatch.GraphicsDevice, 1, 1, false, SurfaceFormat.Color);
//			pixel.SetData(new[] { Color.White });
//		}


//		/// <summary>
//		/// Draws a list of connecting points
//		/// </summary>
//		/// <param name="spriteBatch">The destination drawing surface</param>
//		/// /// <param name="position">Where to position the points</param>
//		/// <param name="points">The points to connect with lines</param>
//		/// <param name="color">The color to use</param>
//		/// <param name="thickness">The thickness of the lines</param>
//		private static void DrawPoints(SpriteBatch spriteBatch, Vector2 position, List<Vector2> points, Color color, float thickness)
//		{
//			if (points.Count < 2)
//				return;

//			for (int i = 1; i < points.Count; i++)
//			{
//				DrawLine(spriteBatch, points[i - 1] + position, points[i] + position, color, thickness);
//			}
//		}


//		/// <summary>
//		/// Creates a list of vectors that represents a circle
//		/// </summary>
//		/// <param name="radius">The radius of the circle</param>
//		/// <param name="sides">The number of sides to generate</param>
//		/// <returns>A list of vectors that, if connected, will create a circle</returns>
//		private static List<Vector2> CreateCircle(double radius, int sides)
//		{
//			// Look for a cached version of this circle
//			String circleKey = radius + "x" + sides;
//			if (circleCache.ContainsKey(circleKey))
//			{
//				return circleCache[circleKey];
//			}

//			List<Vector2> vectors = new List<Vector2>();

//			const double max = 2.0 * Math.PI;
//			double step = max / sides;

//			for (double theta = 0.0; theta < max; theta += step)
//			{
//				vectors.Add(new Vector2((float)(radius * Math.Cos(theta)), (float)(radius * Math.Sin(theta))));
//			}

//			// then add the first vector again so it's a complete loop
//			vectors.Add(new Vector2((float)(radius * Math.Cos(0)), (float)(radius * Math.Sin(0))));

//			// Cache this circle so that it can be quickly drawn next time
//			circleCache.Add(circleKey, vectors);

//			return vectors;
//		}

//		#endregion


//		#region PutPixel

//		public static void PutPixel(this SpriteBatch spriteBatch, float x, float y, Color color)
//		{
//			PutPixel(spriteBatch, new Vector2(x, y), color);
//		}


//		public static void PutPixel(this SpriteBatch spriteBatch, Vector2 position, Color color)
//		{
//			if (pixel == null)
//			{
//				CreateThePixel(spriteBatch);
//			}

//			spriteBatch.Draw(pixel, position, color);
//		}

//		#endregion
//	}
//}
